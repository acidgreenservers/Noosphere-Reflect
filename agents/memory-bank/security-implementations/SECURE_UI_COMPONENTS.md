# Secure UI Component Patterns

**Context**: React 19 + TypeScript + Tailwind CSS
**Goal**: Prevent XSS, ensure accessibility, and validate user input at the edge.

## 1. Output Rendering (XSS Prevention)

### ❌ The Anti-Pattern (Dangerous)
```tsx
// NEVER DO THIS with user content
<div dangerouslySetInnerHTML={{ __html: userContent }} />
```

### ✅ The Secure Pattern (React Default)
React automatically escapes content in JSX. Rely on this whenever possible.
```tsx
<div>{userContent}</div>
```

### ⚠️ The "Necessary Evil" (Sanitized HTML)
If you *must* render HTML (e.g., for the chat preview), you **must** ensure the content source is trusted or sanitized *before* it reaches the component.

**Rule**: In Noosphere Reflect, only `converterService.ts` is allowed to generate HTML strings, because it strictly uses `escapeHtml()` and `sanitizeUrl()`.

```tsx
// Acceptable ONLY for previewing content generated by our own trusted converter
<iframe 
  srcDoc={trustedHtmlContent} 
  sandbox="allow-scripts" // Minimal permissions
  title="Safe Preview"
/>
```

## 2. Input Handling

### Text Inputs
Always bind inputs to React state. Use the `INPUT_LIMITS` constants from `securityUtils.ts`.

```tsx
import { INPUT_LIMITS } from '../utils/securityUtils';

<input
  type="text"
  value={title}
  onChange={(e) => setTitle(e.target.value)}
  maxLength={INPUT_LIMITS.TITLE_MAX_LENGTH} // Hard limit in DOM
  className="..."
/>
```

### Tag Inputs
Validate tags against the allow-list regex in `securityUtils`.

```tsx
import { validateTag } from '../utils/securityUtils';

const handleAddTag = (newTag: string) => {
  const validation = validateTag(newTag);
  if (!validation.valid) {
    setError(validation.error);
    return;
  }
  // Proceed...
};
```

## 3. File Inputs (Artifacts)
Never trust the file extension or MIME type provided by the browser blindly.

```tsx
import { validateFileSize, INPUT_LIMITS } from '../utils/securityUtils';

const handleFileSelect = (files: FileList) => {
  const file = files[0];
  
  // 1. Check Size
  const sizeCheck = validateFileSize(file.size, INPUT_LIMITS.FILE_MAX_SIZE_MB);
  if (!sizeCheck.valid) {
    alert(sizeCheck.error);
    return;
  }
  
  // 2. Read content (prefer ArrayBuffer or text over Data URL if possible, or strip prefix)
  // ...
}
```

## 4. Event Handlers
Avoid inline function definitions for complex logic to prevent closure staleness and make auditing easier.

```tsx
// ✅ Good
const handleClick = (id: string) => {
  if (!isValidId(id)) return;
  deleteItem(id);
};

return <button onClick={() => handleClick(item.id)}>Delete</button>;
```

## 5. Visual Security (CSS)
Ensure UI elements cannot be used to "spoof" system messages.

*   **Chat Bubbles**: User and AI bubbles must be visually distinct (colors/alignment).
*   **System Messages**: Use a distinct style (e.g., centered, gray text, italic) that user input cannot mimic.
*   **Z-Index**: Ensure modals and overlays have proper stacking contexts to prevent "clickjacking" or obscuring critical buttons.
