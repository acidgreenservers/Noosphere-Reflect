import { BaseMarkdownParser } from './BaseMarkdownParser';
import { ChatData, ChatMessage, ChatMessageType, ChatMetadata } from '../../../types';

/**
 * NoosphereMarkdownParser specifically handles the high-fidelity Noosphere Reflect 
 * export standard generated by the platform DOM scrapers.
 */
export class NoosphereMarkdownParser extends BaseMarkdownParser {
    parse(input: string): ChatData {
        const metadata = this.extractNoosphereMetadata(input);
        const messages = this.parseNoosphereTurns(input);

        if (messages.length === 0) {
            // Fallback to standard turns if Noosphere-specific ones fail
            const fallbackMessages = this.parseStandardTurns(input);
            if (fallbackMessages.length === 0) {
                throw new Error('No valid Noosphere Reflect conversation turns detected. Ensure "#### Prompt" headings are present.');
            }
            return { messages: fallbackMessages, metadata };
        }

        return { messages, metadata };
    }

    private extractNoosphereMetadata(input: string): ChatMetadata {
        const metadata: ChatMetadata = {
            title: 'Noosphere Conversation',
            model: 'Unknown',
            date: new Date().toISOString(),
            tags: ['noosphere-reflect']
        };

        // 1. Extract Title from the dedicated "## Title:" section
        const titleMatch = input.match(/## Title:\s*\n\n>\s*(.+)/i);
        if (titleMatch) {
            metadata.title = titleMatch[1].trim();
        } else {
            // Fallback title detection
            const h1Match = input.match(/^#\s+(.+)/m);
            if (h1Match) metadata.title = h1Match[1].trim();
        }

        // 2. Extract Model from the metadata block
        const modelMatch = input.match(/>\s*\*\*ðŸ¤– Model:\*\*\s*(.+)/i);
        if (modelMatch) {
            metadata.model = modelMatch[1].trim();
            metadata.tags.push(metadata.model.toLowerCase());
        }

        // 3. Extract Date
        const dateMatch = input.match(/>\s*\*\*ðŸŒ Date:\*\*\s*(.+)/i);
        if (dateMatch) {
            metadata.date = dateMatch[1].trim();
        }

        // 4. Extract Source
        const sourceMatch = input.match(/>\s*\*\*ðŸŒ Source:\*\*\s*\[.+\]\((.+)\)/i);
        if (sourceMatch) {
            metadata.sourceUrl = sourceMatch[1].trim();
        }

        // 5. Extract Tags
        const tagsMatch = input.match(/>\s*\*\*ðŸ·ï¸ Tags:\*\*\s*(.+)/i);
        if (tagsMatch) {
            const tags = tagsMatch[1].split(',').map(t => t.trim().toLowerCase());
            metadata.tags = Array.from(new Set([...metadata.tags, ...tags]));
        }

        return metadata;
    }

    private parseNoosphereTurns(input: string): ChatMessage[] {
        const messages: ChatMessage[] = [];
        // Pattern matches "#### Prompt - User ðŸ‘¤:" or "#### Response - Model ðŸ¤–:"
        // and also supports the user's request for varied headings like "### Claude", "### Gemini"
        const headerPattern = /^(?:###|####)\s+(Prompt|User|Response|Model|Claude|Gemini|Grok|Le\s*Chat|Assistant|Human|You|Me)(?:\s+-\s+[^:\n]+)?(?:\s+[ðŸ‘¤ðŸ¤–])?:/gim;

        const matches = Array.from(input.matchAll(headerPattern));
        if (matches.length === 0) return [];

        for (let i = 0; i < matches.length; i++) {
            const headerType = matches[i][1].toLowerCase();
            const contentStart = matches[i].index! + matches[i][0].length;
            const contentEnd = (i + 1 < matches.length) ? matches[i + 1].index : input.search(/\n---\n\n###### Noosphere Reflect/);

            let rawContent = input.substring(contentStart, contentEnd === -1 ? input.length : contentEnd).trim();

            // Detect thoughts specifically in Noosphere format
            let thoughts: string | undefined;
            const thoughtMatch = rawContent.match(/```\nThoughts:\n([\s\S]*?)```/im) ||
                rawContent.match(/```thought\n([\s\S]*?)```/im) ||
                rawContent.match(/<thoughts>([\s\S]*?)<\/thoughts>/im);

            if (thoughtMatch) {
                thoughts = thoughtMatch[1].trim();
                rawContent = rawContent.replace(thoughtMatch[0], '').trim();
            }

            const isPrompt = ['prompt', 'user', 'human', 'you', 'me'].includes(headerType);

            let finalContent = rawContent;
            if (!isPrompt && thoughts) {
                finalContent = `<thoughts>\n\n${thoughts}\n\n</thoughts>\n\n${rawContent}`;
            }

            messages.push({
                type: isPrompt ? ChatMessageType.Prompt : ChatMessageType.Response,
                content: finalContent
            });
        }

        return messages;
    }
}
